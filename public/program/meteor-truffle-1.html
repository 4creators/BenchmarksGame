<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest Ruby Truffle program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h1 small{font-size:0.64em}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#dd4814}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">The&nbsp;<small>Computer&nbsp;Language</small><br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest Ruby Truffle program</h2>
    <aside>
      <p><a href="../description/meteor.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
# The Computer Language Benchmarks Game
# http://benchmarksgame.alioth.debian.org
#   contributed by Kevin Barnes (Ruby novice)

def blank_board
  0b111111100000100000100000100000100000100000100000100000100000100000
end

def is_even( location)
  (location % 12) &lt; 6
end

def create_collector_support
    odd_map = [0b11, 0b110, 0b1100, 0b11000, 0b10000] 
    even_map = [0b1, 0b11, 0b110, 0b1100, 0b11000] 
    
    all_odds = Array.new(0b100000)
    all_evens = Array.new(0b100000)
    bit_counts = Array.new(0b100000)
    new_regions = Array.new(0b100000)
    0.upto(0b11111) do | i |
      bit_count = odd = even = 0
      0.upto(4) do | bit |
        if (i[bit] == 1) then
          bit_count += 1
          odd |= odd_map[bit]
          even |= even_map[bit]
        end
      end
      all_odds[i] = odd
      all_evens[i] = even
      bit_counts[i] = bit_count
      new_regions[i] = create_regions( i)
    end

    &#64;&#64;converter = []
    10.times { | row | &#64;&#64;converter.push((row % 2 == 0) ? all_evens : all_odds) }
    &#64;&#64;bit_counts = bit_counts
    &#64;&#64;regions = new_regions.collect { | set | set.collect { | value | [ value, bit_counts[value], value] } }

  end
  
def prunable( board, location, slotting = false)
  collectors = []
  (location / 6).to_i.upto(9) do | row_on | 
    regions = &#64;&#64;regions[(board &gt;&gt; (row_on * 6)) &amp; 0b11111 ^ 0b11111]
    converter = &#64;&#64;converter[row_on]
    initial_collector_count = collectors.length
    regions.each do | region |
      collector_found = nil
      region_mask = region[0]
      initial_collector_count.times do | collector_num |
        collector = collectors[collector_num]
        if (collector) then
          collector_mask = collector[0]
          if (collector_mask &amp; region_mask != 0) then
            if (collector_found) then
              collector_found[0] |= collector_mask
              collector_found[1] += collector[1]
              collector_found[2] |= collector[2]
              collectors[collector_num] = nil
            else
              collector_found = collector
              collector[1] += region[1]
              collector[2] |= region_mask
            end
          end
        end
      end
      if (collector_found == nil) then
        collectors.push(Array.new(region))
      end
    end
    collectors.length.times do | collector_num |
      collector = collectors[collector_num]
      if (collector) then
        if (collector[2] == 0) then
          return true if (collector[1] % 5 != 0)
          collectors[collector_num] = nil
        else
          return false if (collector[2] == 0b11111 &amp;&amp; !slotting)
          collector[0] = converter[collector[2]]
          collector[2] = 0
        end
      end
    end
    collectors.compact!
  end
  return false if (collectors.length &lt;= 1) 
  collectors.any? { | collector | (collector[1] % 5) != 0 }
end
  
def as_binary( value)
  rtn = &quot;&quot;
  5.times do | i |
    rtn += &quot;#{value[i]}&quot;
  end
  rtn
end
  
def create_regions( value )
  regions = []
  cur_region = 0
  5.times do | bit |
    if (value[bit] == 1) then
      cur_region |= 1 &lt;&lt; bit
    else
      if (cur_region !=0 ) then
        regions.push( cur_region)
        cur_region = 0;
      end
    end
  end
  regions.push(cur_region) if (cur_region != 0)
  regions
end

def print_board( board, padding = &quot;&quot;, rows = 10, row_offset = 0)
  rows.times do | row |
    rtn = padding
    rtn = &quot;#{rtn} &quot; if ((row + row_offset) % 2) == 1 
    6.times do | col | 
      rtn = &quot;#{rtn}#{board[row*6+col]} &quot; 
    end
    print &quot;#{rtn}\n&quot;
  end
end  

class Rotation
  attr_reader :start_masks
  
  &#64;&#64;rotation_even_adder = { :west =&gt; -1, :east =&gt; 1, :nw =&gt; -7, :ne =&gt; -6, :sw =&gt; 5, :se =&gt; 6 }
  &#64;&#64;rotation_odd_adder = { :west =&gt; -1, :east =&gt; 1, :nw =&gt; -6, :ne =&gt; -5, :sw =&gt; 6, :se =&gt; 7 }
  
  def initialize( directions )
    values, min = get_values( directions )
    &#64;even_offsets, &#64;odd_offsets = normalize_offsets( values, min)
      
    &#64;even_mask = mask_for_offsets( &#64;even_offsets)
    &#64;odd_mask = mask_for_offsets( &#64;odd_offsets)

    &#64;start_masks = Array.new(60)
    
    0.upto(59) do | offset |
      mask = is_even(offset) ? (&#64;even_mask &lt;&lt; offset) : (&#64;odd_mask &lt;&lt; offset)
      if (blank_board &amp; mask == 0 &amp;&amp; !prunable(blank_board | mask, 0, true)) then
        &#64;start_masks[offset] = mask
      else
        &#64;start_masks[offset] = false 
      end
    end
  end
  
  def offsets( location)
    if is_even( location) then
      &#64;even_offsets.collect { | value | value + location }
    else
      &#64;odd_offsets.collect { | value | value + location }
    end
  end
  
  def normalize_offsets( values, min)
    even_min = is_even(min)
    other_min = even_min ? min + 6 : min + 7
    other_values = values.collect do | value | 
      if is_even(value) then 
        value + 6 - other_min 
      else 
        value + 7 - other_min 
      end
    end
    values.collect! { | value | value - min }
    
    if even_min then
      [values, other_values]
    else
      [other_values, values]
    end
  end
  
  def mask_for_offsets( offsets )
    mask = 0
    offsets.each { | value | mask = mask + ( 1 &lt;&lt; value ) }
    mask
  end

  def start_adjust( directions )
    south = east = 0;
    directions.each do | direction |
      east += 1 if ( direction == :sw || direction == :nw || direction == :west )
      south += 1 if ( direction == :nw || direction == :ne )   
    end
    [south, east]
  end

  def get_values ( directions )
    south, east = start_adjust(directions)
    min = start = south * 6 + east
    values = [ start ]
    directions.each do | direction |
      if (start % 12 &gt;= 6) then 
        start += &#64;&#64;rotation_odd_adder[direction]
      else 
        start += &#64;&#64;rotation_even_adder[direction]
      end
      min = start if (start &lt; min)
      values += [ start ]
    end
    
    if (values.length != 5)
      values.uniq!
    end
    
    [ values, min ]
  end
end

class Piece
  attr_reader :rotations, :type, :masks
  attr_accessor :placed
  
  &#64;&#64;flip_converter = { :west =&gt; :west, :east =&gt; :east, :nw =&gt; :sw, :ne =&gt; :se, :sw =&gt; :nw, :se =&gt; :ne }
  &#64;&#64;rotate_converter = { :west =&gt; :nw, :east =&gt; :se, :nw =&gt; :ne, :ne =&gt; :east, :sw =&gt; :west, :se =&gt; :sw }
  
  def initialize( directions, type )
    &#64;type = type
    &#64;rotations = Array.new();
    &#64;map = {}
    generate_rotations( directions )
    directions.collect! { | value | &#64;&#64;flip_converter[value] }
    generate_rotations( directions )
    
    &#64;masks = Array.new();
    0.upto(59) do | i |
      &#64;masks[i] = &#64;rotations.collect do | rotation | 
        mask = rotation.start_masks[i]
        &#64;map[mask] = [ i, rotation ] if (mask) 
        mask || nil
      end
      &#64;masks[i].compact!
    end
  end
  
  def generate_rotations( directions ) 
    6.times do
      rotations.push( Rotation.new(directions))
      directions.collect! { | value | &#64;&#64;rotate_converter[value] }
    end
  end
  
  def fill_array( board_array)
    location, rotation = &#64;map[&#64;placed]
    rotation.offsets(location).each do | offset |
      row, col = offset.divmod(6)
      board_array[ row*5 + col ] = &#64;type.to_s
    end
  end
end

class Processor 
  attr :pieces, :board
  
  def initialize() 
    create_collector_support
    &#64;pieces = [ 
      Piece.new( [ :east, :east, :east, :se ], 0),
      Piece.new( [ :ne, :east, :ne, :nw ], 1),
      Piece.new( [ :nw, :ne, :east, :east ], 2),
      Piece.new( [ :east, :east, :sw, :se ], 3),
      Piece.new( [ :ne, :nw, :se, :east, :se ], 4),
      Piece.new( [ :east, :ne, :se, :ne ], 5),
      Piece.new( [ :east, :sw, :sw, :se ], 6),
      Piece.new( [ :ne, :se, :east, :ne ], 7),
      Piece.new( [ :se, :se, :east, :se ], 8),
      Piece.new( [ :se, :se, :se, :west ], 9) ];
      
    &#64;all_pieces = Array.new( &#64;pieces)

    &#64;min_board = &quot;99999999999999999999999999999999999999999999999999&quot;
    &#64;max_board = &quot;00000000000000000000000000000000000000000000000000&quot;
    &#64;stop_count = ARGV[0].to_i || 2089
    &#64;all_boards = {}
    &#64;boards_found = 0
  end
  
  def find_all
    find_top( 0)
    find_top( 1)
    print_results
  end

  def print_results
    print &quot;#{&#64;boards_found} solutions found\n\n&quot;
    print_full_board( &#64;min_board)
    print &quot;\n&quot;
    print_full_board( &#64;max_board)
    print &quot;\n&quot;
  end

  def find_top( rotation_skip) 
    board = blank_board
    &#64;pieces.length.times do
      piece = &#64;pieces.shift
      piece.masks[0].each do | mask |
        if ((rotation_skip += 1) % 2 == 0) then
          piece.placed = mask
          find( 1, 1, board | mask) 
        end
      end
      &#64;pieces.push(piece)
    end
  end

  def find( start_location, placed, board) 
    while board[start_location] == 1
      start_location += 1 
    end

    return if (start_location &lt; 28 &amp;&amp; prunable( board, start_location))
    
    &#64;pieces.length.times do
      piece = &#64;pieces.shift
      piece.masks[start_location].each do | mask |
        if (mask &amp; board == 0) then
          piece.placed = mask
          if (placed == 9) then
            add_board
          else
            find( start_location + 1, placed + 1, board | mask) 
          end
        end
      end
      &#64;pieces.push(piece)
    end
  end
  
  def print_full_board( board_string)
    10.times do | row |
      print &quot; &quot; if (row % 2 == 1) 
      5.times do | col |
        print &quot;#{board_string[row*5 + col,1]} &quot;
      end
      print &quot;\n&quot;
    end
  end
  
  def add_board
    board_array = Array.new(50)
    &#64;all_pieces.each do | piece |
      piece.fill_array( board_array )
    end
    start_board = board_string = board_array.join(&quot;&quot;)
    save( board_string)
    board_string = flip( board_string)
    save( board_string)
  end

  def flip( board_string)
    new_string = &quot;&quot;
    50.times do | i |
      row, col = i.divmod(5)
      new_string += board_string[((9 - row) * 5) + (4 - col), 1]
    end
    new_string
  end
      
  def save( board_string)
    if (&#64;all_boards[board_string] == nil) then
      &#64;min_board = board_string if (board_string &lt; &#64;min_board)
      &#64;max_board = board_string if (board_string &gt; &#64;max_board)
      &#64;all_boards.store(board_string,true)
      &#64;boards_found += 1

      if (&#64;boards_found == &#64;stop_count) then
        print_results
        exit(0)
      end
    end
  end
  
end

proc = Processor.new.find_all

    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
truffleruby 1.0.0-rc1, like ruby 2.3.7  [x86_64-linux]


Sat, 21 Apr 2018 01:48:55 GMT

COMMAND LINE:
/opt/src/graalvm-ce-1.0.0-rc1-linux-amd64/graalvm-1.0.0-rc1/bin/truffleruby --jvm -W0 meteor.truffle 2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="../license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

